export class Formatter {
    /**
     * Format multiple transcripts
     * @param transcripts Array of transcripts to format
     * @returns Formatted string containing all transcripts
     */
    formatTranscripts(transcripts) {
        // Default implementation concatenates individual formats
        return transcripts.map(t => this.format(t)).join('\n\n\n');
    }
}
export class JSONFormatter extends Formatter {
    format(transcript) {
        return JSON.stringify(transcript, null, 2);
    }
    /**
     * Format multiple transcripts as a JSON array
     */
    formatTranscripts(transcripts) {
        return JSON.stringify(transcripts, null, 2);
    }
}
export class TextFormatter extends Formatter {
    format(transcript) {
        return transcript.snippets.map(line => line.text).join('\n');
    }
}
class TextBasedFormatter extends TextFormatter {
    secondsToTimestamp(time) {
        const [hours, remainder] = this.divmod(time, 3600);
        const [mins, secs] = this.divmod(remainder, 60);
        const ms = Math.round((time - Math.floor(time)) * 1000);
        return this.formatTimestamp(Math.floor(hours), Math.floor(mins), Math.floor(secs), ms);
    }
    divmod(n, d) {
        return [Math.floor(n / d), n % d];
    }
    format(transcript) {
        const lines = transcript.snippets.map((line, i) => {
            const end = line.start + line.duration;
            const nextStart = i < transcript.snippets.length - 1 ? transcript.snippets[i + 1].start : end;
            const timeText = `${this.secondsToTimestamp(line.start)} --> ${this.secondsToTimestamp(nextStart < end ? nextStart : end)}`;
            return this.formatTranscriptLine(i, timeText, line);
        });
        return this.formatTranscriptHeader(lines);
    }
    /**
     * Format multiple transcripts with separator
     */
    formatTranscripts(transcripts) {
        return transcripts
            .map((transcript, i) => {
            const header = `TRANSCRIPT ${i + 1}:`;
            return `${header}\n${this.format(transcript)}`;
        })
            .join('\n\n');
    }
}
export class SRTFormatter extends TextBasedFormatter {
    formatTimestamp(hours, mins, secs, ms) {
        return `${this.pad(hours)}:${this.pad(mins)}:${this.pad(secs)},${this.pad(ms, 3)}`;
    }
    formatTranscriptHeader(lines) {
        return lines.join('\n\n') + '\n';
    }
    formatTranscriptLine(index, timeText, snippet) {
        return `${index + 1}\n${timeText}\n${snippet.text}`;
    }
    pad(num, width = 2) {
        return num.toString().padStart(width, '0');
    }
}
export class WebVTTFormatter extends TextBasedFormatter {
    formatTimestamp(hours, mins, secs, ms) {
        return `${this.pad(hours)}:${this.pad(mins)}:${this.pad(secs)}.${this.pad(ms, 3)}`;
    }
    formatTranscriptHeader(lines) {
        return `WEBVTT\n\n${lines.join('\n\n')}\n`;
    }
    formatTranscriptLine(index, timeText, snippet) {
        return `${timeText}\n${snippet.text}`;
    }
    pad(num, width = 2) {
        return num.toString().padStart(width, '0');
    }
}
export class FormatterFactory {
    static create(type = 'json') {
        const FormatterClass = FormatterFactory.TYPES[type];
        if (!FormatterClass) {
            throw new Error(`The format '${type}' is not supported. Choose one of the following formats: ${Object.keys(FormatterFactory.TYPES).join(', ')}`);
        }
        return new FormatterClass();
    }
}
FormatterFactory.TYPES = {
    json: JSONFormatter,
    text: TextFormatter,
    srt: SRTFormatter,
    webvtt: WebVTTFormatter,
};
//# sourceMappingURL=formatters.js.map