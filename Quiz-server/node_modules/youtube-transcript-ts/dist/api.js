import axios from 'axios';
import { decode } from 'html-entities';
import { FormatterFactory } from './formatters';
import { NoTranscriptFound, NotTranslatable, TranslationLanguageNotAvailable, VideoUnavailable, IpBlocked, TranscriptsDisabled, } from './types';
// Import proxy agents
import { HttpProxyAgent } from 'http-proxy-agent';
import { HttpsProxyAgent } from 'https-proxy-agent';
const WATCH_URL = 'https://www.youtube.com/watch';
const USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36,gzip(gfe)';
/**
 * Main YouTube Transcript API class for fetching and processing transcripts
 */
export class YouTubeTranscriptApi {
    /**
     * Create a new YouTubeTranscriptApi instance
     * @param options Configuration options for the API
     */
    constructor(options = {}) {
        this.invidiousClient = null;
        // Initialize cache
        this.cache = {
            html: new Map(),
            transcript: new Map(),
        };
        // Default cache options
        this.cacheOptions = {
            enabled: true,
            maxAge: 3600000, // 1 hour default cache
            ...options.cache,
        };
        // Default logger options
        this.loggerOptions = {
            enabled: false,
            namespace: 'youtube-transcript',
            ...options.logger,
        };
        // Default Invidious options (no default instance URL)
        this.invidiousOptions = {
            enabled: false,
            instanceUrls: '',
            timeout: 10000,
            ...options.invidious,
        };
        // Default proxy options
        this.proxyOptions = {
            enabled: false,
            http: '',
            https: '',
            ...options.proxy,
        };
        // Initialize Invidious client if enabled
        if (this.invidiousOptions.enabled) {
            const instanceUrls = Array.isArray(this.invidiousOptions.instanceUrls)
                ? this.invidiousOptions.instanceUrls
                : [this.invidiousOptions.instanceUrls];
            if (instanceUrls.length === 0 || (instanceUrls.length === 1 && !instanceUrls[0])) {
                throw new Error('At least one Invidious instance URL must be provided when Invidious is enabled');
            }
            this.initInvidiousClient();
        }
        // Configure axios with performance optimizations
        this.httpClient = axios.create({
            headers: {
                'Accept-Language': 'en-US',
                'User-Agent': USER_AGENT,
                'Accept-Encoding': 'gzip, deflate, br', // Enable compression
            },
            timeout: 10000, // 10 second timeout
            maxRedirects: 5,
            // Add proxy configuration if enabled
            ...(this.proxyOptions.enabled
                ? {
                    proxy: false, // Disable the built-in proxy resolver to use the httpAgent/httpsAgent
                    ...(typeof window === 'undefined'
                        ? {
                            // Only use these in Node.js environments
                            httpAgent: new HttpProxyAgent(this.proxyOptions.http || ''),
                            httpsAgent: new HttpsProxyAgent(this.proxyOptions.https || this.proxyOptions.http || ''),
                        }
                        : {}),
                }
                : // We don't set keep-alive agents in browser environments
                    typeof window === 'undefined'
                        ? {
                            // Only use these in Node.js environments
                            httpAgent: new (require('http').Agent)({
                                keepAlive: true,
                            }),
                            httpsAgent: new (require('https').Agent)({
                                keepAlive: true,
                            }),
                        }
                        : {}),
        });
    }
    /**
     * Configure logging behavior
     * @param options Logger configuration options
     */
    setLoggerOptions(options) {
        this.loggerOptions = {
            ...this.loggerOptions,
            ...options,
        };
    }
    /**
     * Configure caching behavior
     * @param options Cache configuration options
     */
    setCacheOptions(options) {
        this.cacheOptions = {
            ...this.cacheOptions,
            ...options,
        };
    }
    /**
     * Configure proxy settings for all requests
     * @param options Proxy configuration options
     */
    setProxyOptions(options) {
        this.proxyOptions = {
            ...this.proxyOptions,
            ...options,
        };
        // Reinitialize the HTTP client with the new proxy settings
        this.httpClient = axios.create({
            headers: {
                'Accept-Language': 'en-US',
                'User-Agent': USER_AGENT,
                'Accept-Encoding': 'gzip, deflate, br', // Enable compression
            },
            timeout: 10000, // 10 second timeout
            maxRedirects: 5,
            // Add proxy configuration if enabled
            ...(this.proxyOptions.enabled
                ? {
                    proxy: false, // Disable the built-in proxy resolver to use the httpAgent/httpsAgent
                    ...(typeof window === 'undefined'
                        ? {
                            // Only use these in Node.js environments
                            httpAgent: new HttpProxyAgent(this.proxyOptions.http || ''),
                            httpsAgent: new HttpsProxyAgent(this.proxyOptions.https || this.proxyOptions.http || ''),
                        }
                        : {}),
                }
                : // We don't set keep-alive agents in browser environments
                    typeof window === 'undefined'
                        ? {
                            // Only use these in Node.js environments
                            httpAgent: new (require('http').Agent)({
                                keepAlive: true,
                            }),
                            httpsAgent: new (require('https').Agent)({
                                keepAlive: true,
                            }),
                        }
                        : {}),
        });
        // If there are cookies set, reapply them to the new client
        if (this.httpClient.defaults.headers.common['Cookie']) {
            const cookieString = this.httpClient.defaults.headers.common['Cookie'];
            this.httpClient.defaults.headers.common['Cookie'] = cookieString;
        }
        // Reinitialize Invidious client if it's enabled
        if (this.invidiousOptions.enabled) {
            this.initInvidiousClient();
        }
    }
    /**
     * Configure Invidious fallback behavior
     * @param options Invidious configuration options
     */
    setInvidiousOptions(options) {
        this.invidiousOptions = {
            ...this.invidiousOptions,
            ...options,
        };
        // Initialize or update Invidious client if enabled
        if (this.invidiousOptions.enabled) {
            const instanceUrls = Array.isArray(this.invidiousOptions.instanceUrls)
                ? this.invidiousOptions.instanceUrls
                : [this.invidiousOptions.instanceUrls];
            if (instanceUrls.length === 0 || (instanceUrls.length === 1 && !instanceUrls[0])) {
                throw new Error('At least one Invidious instance URL must be provided when Invidious is enabled');
            }
            this.initInvidiousClient();
        }
        else {
            this.invidiousClient = null;
        }
    }
    /**
     * Initialize the Invidious API client
     * @private
     */
    initInvidiousClient() {
        // Get the first instance URL as the default
        const instanceUrls = Array.isArray(this.invidiousOptions.instanceUrls)
            ? this.invidiousOptions.instanceUrls
            : [this.invidiousOptions.instanceUrls];
        const primaryInstanceUrl = instanceUrls[0];
        this.invidiousClient = axios.create({
            baseURL: primaryInstanceUrl,
            timeout: this.invidiousOptions.timeout || 10000,
            headers: {
                Accept: 'application/json',
                'User-Agent': USER_AGENT,
            },
            // Add proxy configuration if enabled
            ...(this.proxyOptions.enabled
                ? {
                    proxy: false, // Disable the built-in proxy resolver to use the httpAgent/httpsAgent
                    ...(typeof window === 'undefined'
                        ? {
                            // Only use these in Node.js environments
                            httpAgent: new HttpProxyAgent(this.proxyOptions.http || ''),
                            httpsAgent: new HttpsProxyAgent(this.proxyOptions.https || this.proxyOptions.http || ''),
                        }
                        : {}),
                }
                : {}),
        });
        // Store all instance URLs for fallback use
        this.invidiousClient.__instanceUrls = instanceUrls;
        this.invidiousClient.__currentInstanceIndex = 0;
        // Validate the Invidious instance by making a test request
        this.validateInvidiousInstance().catch(error => {
            this.log('error', `Failed to validate primary Invidious instance at ${primaryInstanceUrl}`, error);
            // If we have multiple instances, we'll try others when making actual requests
            if (instanceUrls.length > 1) {
                this.log('info', `Will try ${instanceUrls.length - 1} alternative instance(s) when needed`);
            }
            else {
                this.log('info', 'Invidious fallback will be disabled');
                this.invidiousClient = null;
            }
        });
    }
    /**
     * Validate that the configured Invidious instance is available and working
     * @private
     */
    async validateInvidiousInstance() {
        if (!this.invidiousClient) {
            return false;
        }
        try {
            // Make a simple request to the Invidious API to check if it's working
            const response = await this.invidiousClient.get('/api/v1/stats', {
                timeout: 5000, // Short timeout for this test
            });
            if (response.status !== 200) {
                this.log('error', `Invidious instance returned non-200 status: ${response.status}`);
                return false;
            }
            const instanceUrls = Array.isArray(this.invidiousOptions.instanceUrls)
                ? this.invidiousOptions.instanceUrls
                : [this.invidiousOptions.instanceUrls];
            const primaryInstanceUrl = instanceUrls[0];
            this.log('info', `Successfully validated Invidious instance at ${primaryInstanceUrl}`);
            return true;
        }
        catch (error) {
            this.log('error', 'Invidious instance validation failed', error);
            return false;
        }
    }
    /**
     * Tries to get an Invidious instance that works
     * @param operation The operation to perform with the client
     * @returns The result of the operation
     * @private
     */
    async tryWithInvidiousInstances(operation) {
        if (!this.invidiousClient) {
            throw new Error('Invidious client not initialized');
        }
        const instanceUrls = this.invidiousClient.__instanceUrls ||
            (Array.isArray(this.invidiousOptions.instanceUrls)
                ? this.invidiousOptions.instanceUrls
                : [this.invidiousOptions.instanceUrls]);
        let lastError = null;
        // Try each instance in order
        for (let i = 0; i < instanceUrls.length; i++) {
            const instanceUrl = instanceUrls[i];
            try {
                // Update the client's base URL to the current instance
                this.invidiousClient.defaults.baseURL = instanceUrl;
                this.invidiousClient.__currentInstanceIndex = i;
                this.log('info', `Trying Invidious instance: ${instanceUrl}`);
                return await operation(this.invidiousClient, instanceUrl);
            }
            catch (error) {
                this.log('error', `Failed with Invidious instance ${instanceUrl}`, error);
                lastError = error;
                // Continue to the next instance
            }
        }
        // If we get here, all instances failed
        throw lastError || new Error('All Invidious instances failed');
    }
    /**
     * Sets cookies for authentication (useful for age-restricted videos)
     * @param cookies Dictionary of cookie name-value pairs
     */
    setCookies(cookies) {
        // Update axios instance with cookies
        const cookieString = Object.entries(cookies)
            .map(([name, value]) => `${name}=${value}`)
            .join('; ');
        this.httpClient.defaults.headers.common['Cookie'] = cookieString;
    }
    /**
     * Internal method to log messages
     * @param type Type of log (e.g., 'performance', 'error')
     * @param message Log message
     * @param data Optional data to log
     * @private
     */
    log(type, message, data) {
        if (!this.loggerOptions.enabled)
            return;
        const { namespace, logger } = this.loggerOptions;
        const prefix = namespace ? `${namespace}:${type}` : type;
        // Use custom logger if provided
        if (logger && logger(type, message, data)) {
            return; // Custom logger handled it (returned true)
        }
        // Default logging behavior
        if (data !== undefined) {
            console.log(`[${prefix}] ${message}`, data);
        }
        else {
            console.log(`[${prefix}] ${message}`);
        }
    }
    /**
     * Clear the internal cache
     * @param type Optional cache type to clear (html, transcript, or both if undefined)
     */
    clearCache(type) {
        if (!type || type === 'html') {
            this.cache.html.clear();
        }
        if (!type || type === 'transcript') {
            this.cache.transcript.clear();
        }
    }
    /**
     * Extracts video ID from various YouTube URL formats or returns the ID if already an ID
     * @param videoIdOrUrl Video ID or YouTube URL (various formats supported)
     * @returns Extracted video ID
     */
    static getVideoId(videoIdOrUrl) {
        if (!videoIdOrUrl) {
            throw new Error('Video ID or URL cannot be empty');
        }
        // Already a video ID (not a URL)
        if (!videoIdOrUrl.includes('/') && !videoIdOrUrl.includes('.')) {
            return videoIdOrUrl;
        }
        // Try to parse as URL
        let url;
        try {
            url = new URL(videoIdOrUrl);
        }
        catch (e) {
            throw new Error(`Invalid YouTube URL or video ID: ${videoIdOrUrl}`);
        }
        // youtu.be short URL format
        if (url.hostname === 'youtu.be') {
            const id = url.pathname.slice(1);
            if (id)
                return id;
        }
        // youtube.com domain
        if (url.hostname === 'youtube.com' ||
            url.hostname === 'www.youtube.com' ||
            url.hostname === 'm.youtube.com') {
            // Standard watch URL with query parameter v=ID
            if (url.pathname === '/watch') {
                const id = url.searchParams.get('v');
                if (id)
                    return id;
            }
            // Shorts format
            if (url.pathname.startsWith('/shorts/')) {
                const id = url.pathname.slice('/shorts/'.length);
                if (id)
                    return id.split('/')[0];
            }
            // Embed format
            if (url.pathname.startsWith('/embed/')) {
                const id = url.pathname.slice('/embed/'.length);
                if (id)
                    return id.split('/')[0];
            }
            // Live format
            if (url.pathname.startsWith('/live/')) {
                const id = url.pathname.slice('/live/'.length);
                if (id)
                    return id.split('/')[0];
            }
        }
        throw new Error(`Could not extract video ID from: ${videoIdOrUrl}`);
    }
    /**
     * Check if a cached entry is still valid
     * @param entry The cache entry to check
     * @returns True if the entry is valid, false if expired
     * @private
     */
    isCacheValid(entry) {
        if (!this.cacheOptions.enabled || !entry)
            return false;
        return Date.now() - entry.timestamp < this.cacheOptions.maxAge;
    }
    /**
     * Fetch transcript for a video
     * @param videoIdOrUrl Video ID or YouTube URL
     * @param languages Optional array of language codes to try in order
     * @param preserveFormatting Whether to preserve text formatting
     * @param formatter Optional formatter to format the output
     * @returns TranscriptResponse with transcript data and metadata
     */
    async fetchTranscript(videoIdOrUrl, languages = ['en'], preserveFormatting = false, formatter) {
        const startTotal = Date.now();
        const timings = {};
        const videoId = YouTubeTranscriptApi.getVideoId(videoIdOrUrl);
        const logPerformance = (step, startTime) => {
            const duration = Date.now() - startTime;
            timings[step] = duration;
            this.log('performance', `${step}: ${duration}ms`);
        };
        // Determine if we should try Invidious first based on conditions:
        // Invidious option is enabled and client is available
        const shouldTryInvidiousFirst = this.invidiousOptions.enabled && this.invidiousClient;
        // If we should try Invidious first, do that before attempting YouTube
        if (shouldTryInvidiousFirst) {
            this.log('info', `Attempting to get transcript via Invidious first for video ${videoId}`);
            const startInvidiousFetch = Date.now();
            try {
                const response = await this.fetchTranscriptFromInvidious(videoId, languages, preserveFormatting, formatter);
                logPerformance('Invidious First Attempt', startInvidiousFetch);
                this.log('info', `Successfully fetched transcript from Invidious for video ${videoId}`);
                return response;
            }
            catch (invidiousError) {
                this.log('error', `Invidious first attempt failed for video ${videoId}, falling back to YouTube`, invidiousError);
                // Fall back to normal YouTube fetching process
            }
        }
        try {
            const htmlCacheKey = `html:${videoId}`;
            const transcriptCacheKey = `transcript:${videoId}:${languages.join(',')}:${preserveFormatting}`;
            // Check cache for transcript
            const cachedTranscript = this.cache.transcript.get(transcriptCacheKey);
            if (this.isCacheValid(cachedTranscript)) {
                this.log('performance', 'Using cached transcript');
                // Fetch HTML for metadata
                const html = await this.fetchVideoHtml(videoId);
                const metadata = this.extractMetadata(html);
                const response = {
                    transcript: cachedTranscript.data,
                    metadata,
                    formattedText: undefined,
                };
                // Apply formatter if specified
                if (formatter) {
                    const startFormatting = Date.now();
                    response.formattedText = FormatterFactory.create(formatter).format(cachedTranscript.data);
                    logPerformance('Apply Formatting', startFormatting);
                }
                return response;
            }
            // Fetch video HTML
            const startHtmlFetch = Date.now();
            let html;
            const cachedHtml = this.cache.html.get(htmlCacheKey);
            if (this.isCacheValid(cachedHtml)) {
                html = cachedHtml.data;
                this.log('performance', 'Using cached HTML');
            }
            else {
                html = await this.fetchVideoHtml(videoId);
                // Store in cache
                this.cache.html.set(htmlCacheKey, {
                    data: html,
                    timestamp: Date.now(),
                });
            }
            logPerformance('HTML Fetch', startHtmlFetch);
            // Extract metadata
            const startMetadataExtract = Date.now();
            const metadata = this.extractMetadata(html);
            logPerformance('Metadata Extract', startMetadataExtract);
            // Extract captions data
            const startCaptionsExtract = Date.now();
            const captionsJson = this.extractCaptionsJson(html, videoId);
            logPerformance('Captions Extract', startCaptionsExtract);
            // Build transcript list
            const startBuildList = Date.now();
            const transcriptList = TranscriptList.build(this.httpClient, videoId, captionsJson);
            logPerformance('Build Transcript List', startBuildList);
            // Find appropriate language
            const startFindTranscript = Date.now();
            const transcript = await transcriptList.findTranscript(languages);
            logPerformance('Find Transcript', startFindTranscript);
            // Fetch transcript content
            const startFetchContent = Date.now();
            const transcriptData = await transcript.fetch(preserveFormatting);
            logPerformance('Fetch Content', startFetchContent);
            // Store transcript in cache
            this.cache.transcript.set(transcriptCacheKey, {
                data: transcriptData,
                timestamp: Date.now(),
            });
            const response = {
                transcript: transcriptData,
                metadata: metadata,
                formattedText: undefined,
            };
            // Apply formatter if specified
            if (formatter) {
                const startFormatting = Date.now();
                response.formattedText = FormatterFactory.create(formatter).format(transcriptData);
                logPerformance('Apply Formatting', startFormatting);
            }
            logPerformance('Total', startTotal);
            this.log('performance', 'Summary', timings);
            return response;
        }
        catch (error) {
            // If YouTube fetch fails and Invidious fallback is enabled (and we haven't tried it yet), try Invidious
            if (this.invidiousOptions.enabled && this.invidiousClient && !shouldTryInvidiousFirst) {
                this.log('info', `YouTube fetch failed, falling back to Invidious for video ${videoId}`);
                const startInvidiousFetch = Date.now();
                try {
                    const response = await this.fetchTranscriptFromInvidious(videoId, languages, preserveFormatting, formatter);
                    logPerformance('Invidious Fallback', startInvidiousFetch);
                    this.log('info', `Successfully fetched transcript from Invidious for video ${videoId}`);
                    return response;
                }
                catch (invidiousError) {
                    this.log('error', `Invidious fallback also failed for video ${videoId}`, invidiousError);
                    throw error; // Throw the original YouTube error
                }
            }
            // If Invidious is not enabled or also failed, rethrow the original error
            throw error;
        }
    }
    /**
     * Fetches a transcript from Invidious API
     * @param videoId YouTube video ID
     * @param languages List of language codes to search for (in order of preference)
     * @param preserveFormatting Whether to keep select HTML text formatting
     * @param formatter Optional formatter to format the output (json, text, srt, webvtt)
     * @returns TranscriptResponse with data from Invidious
     * @private
     */
    async fetchTranscriptFromInvidious(videoId, languages = ['en'], preserveFormatting = false, formatter) {
        if (!this.invidiousClient) {
            throw new Error('Invidious client not initialized');
        }
        return this.tryWithInvidiousInstances(async (client, instanceUrl) => {
            var _a, _b;
            try {
                // First get video info from Invidious
                const videoResponse = await client.get(`/api/v1/videos/${videoId}`).catch(error => {
                    this.log('error', `Failed to fetch video info from Invidious for video ${videoId}`, error);
                    throw new VideoUnavailable(videoId);
                });
                if (!videoResponse || !videoResponse.data) {
                    this.log('error', `Empty response from Invidious for video ${videoId}`);
                    throw new VideoUnavailable(videoId);
                }
                const videoData = videoResponse.data;
                // Extract metadata
                const metadata = {
                    id: videoData.videoId,
                    title: videoData.title,
                    description: videoData.description || '',
                    author: videoData.author,
                    channelId: videoData.authorId,
                    lengthSeconds: videoData.lengthSeconds || 0,
                    viewCount: parseInt(videoData.viewCount || '0', 10),
                    isPrivate: false, // Invidious doesn't provide this info
                    isLiveContent: videoData.liveNow || false,
                    publishDate: videoData.published || '',
                    category: videoData.genre || '',
                    keywords: videoData.keywords || [],
                    thumbnails: ((_a = videoData.videoThumbnails) === null || _a === void 0 ? void 0 : _a.map((thumb) => ({
                        url: thumb.url,
                        width: thumb.width,
                        height: thumb.height,
                    }))) || [],
                };
                // Get available captions from Invidious
                let captionsData;
                try {
                    const captionsResponse = await client.get(`/api/v1/captions/${videoId}`);
                    captionsData = captionsResponse.data;
                    if (!captionsData || !Array.isArray(captionsData.captions)) {
                        this.log('error', `Invalid captions data from Invidious for video ${videoId}`);
                        throw new NoTranscriptFound(videoId, languages);
                    }
                }
                catch (error) {
                    this.log('error', `Failed to fetch captions from Invidious for video ${videoId}`, error);
                    throw new NoTranscriptFound(videoId, languages);
                }
                // Find the best matching language
                let selectedCaptionTrack = null;
                for (const language of languages) {
                    const track = (_b = captionsData.captions) === null || _b === void 0 ? void 0 : _b.find((cap) => cap.languageCode === language);
                    if (track) {
                        selectedCaptionTrack = track;
                        break;
                    }
                }
                if (!selectedCaptionTrack) {
                    throw new NoTranscriptFound(videoId, languages);
                }
                // Fetch the actual transcript data using the URL provided in the captions response
                let vttContent;
                try {
                    // The URL is provided in the captionTrack from the API response
                    const captionUrl = selectedCaptionTrack.url;
                    if (!captionUrl) {
                        throw new Error(`No caption URL found for language ${selectedCaptionTrack.languageCode}`);
                    }
                    // The URL in the response is relative, we need to use it directly with the client
                    const transcriptResponse = await client.get(captionUrl);
                    vttContent = transcriptResponse.data;
                    if (!vttContent || typeof vttContent !== 'string') {
                        this.log('error', `Invalid transcript data from Invidious for video ${videoId}`);
                        throw new Error('Invalid transcript data format from Invidious');
                    }
                }
                catch (error) {
                    this.log('error', `Failed to fetch transcript data from Invidious for video ${videoId}`, error);
                    throw new NoTranscriptFound(videoId, languages);
                }
                // Parse the WebVTT format returned by Invidious
                const snippets = this.parseWebVTT(vttContent, preserveFormatting);
                if (snippets.length === 0) {
                    this.log('error', `Empty transcript from Invidious for video ${videoId}`);
                    throw new NoTranscriptFound(videoId, languages);
                }
                const transcript = {
                    snippets,
                    videoId,
                    language: selectedCaptionTrack.label || selectedCaptionTrack.languageCode,
                    languageCode: selectedCaptionTrack.languageCode,
                    isGenerated: selectedCaptionTrack.kind === 'asr',
                };
                // Create the response object
                const response = {
                    transcript,
                    metadata,
                    formattedText: undefined,
                };
                // Apply formatter if specified
                if (formatter) {
                    response.formattedText = FormatterFactory.create(formatter).format(transcript);
                }
                // Cache the result
                const transcriptCacheKey = `transcript:${videoId}:${languages.join(',')}:${preserveFormatting}`;
                this.cache.transcript.set(transcriptCacheKey, {
                    data: transcript,
                    timestamp: Date.now(),
                });
                return response;
            }
            catch (error) {
                this.log('error', `Error fetching from Invidious for video ${videoId}`, error);
                throw error; // Rethrow to allow trying the next instance
            }
        });
    }
    /**
     * Parses WebVTT format returned by Invidious
     * @param vttContent The WebVTT content as string
     * @param preserveFormatting Whether to preserve HTML formatting
     * @returns Array of transcript snippets
     */
    parseWebVTT(vttContent, preserveFormatting) {
        const snippets = [];
        // Split by lines and process
        const lines = vttContent.split('\n');
        let i = 0;
        // Skip header (usually WEBVTT or empty lines at the start)
        while (i < lines.length &&
            (lines[i].trim() === '' || lines[i].trim().startsWith('WEBVTT') || !lines[i].includes('-->'))) {
            i++;
        }
        // Process cues
        while (i < lines.length) {
            const line = lines[i].trim();
            // Check if this is a timestamp line
            if (line.includes('-->')) {
                const times = line.split('-->').map(t => t.trim());
                if (times.length === 2) {
                    const startTime = this.timeToSeconds(times[0]);
                    const endTime = this.timeToSeconds(times[1]);
                    const duration = endTime - startTime;
                    // Get the text content (usually in the next line)
                    i++;
                    let textContent = '';
                    // Collect all text lines until we hit an empty line or another timestamp
                    while (i < lines.length && lines[i].trim() !== '' && !lines[i].includes('-->')) {
                        if (textContent)
                            textContent += '\n';
                        textContent += lines[i].trim();
                        i++;
                    }
                    // Clean the text if needed
                    const text = preserveFormatting ? textContent : textContent.replace(/<[^>]*>/g, '');
                    if (text.trim()) {
                        snippets.push({
                            text: text.trim(),
                            start: startTime,
                            duration: duration,
                        });
                    }
                    // Skip any empty lines before the next timestamp
                    while (i < lines.length && lines[i].trim() === '') {
                        i++;
                    }
                    continue;
                }
            }
            // If we're here, move to the next line
            i++;
        }
        return snippets;
    }
    /**
     * Converts WebVTT timestamp to seconds
     * @param timestamp WebVTT timestamp (HH:MM:SS.mmm)
     * @returns Time in seconds
     */
    timeToSeconds(timestamp) {
        const parts = timestamp.split(':');
        let seconds = 0;
        if (parts.length === 3) {
            // HH:MM:SS.mmm
            seconds = parseFloat(parts[0]) * 3600 + parseFloat(parts[1]) * 60 + parseFloat(parts[2]);
        }
        else if (parts.length === 2) {
            // MM:SS.mmm
            seconds = parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
        }
        else {
            // Invalid format
            seconds = 0;
        }
        return seconds;
    }
    /**
     * Fetch video HTML content
     * @param videoId Video ID
     * @returns HTML content as string
     * @private
     */
    async fetchVideoHtml(videoId) {
        var _a;
        try {
            const response = await this.httpClient.get(WATCH_URL, {
                params: { v: videoId },
            });
            if (response.status !== 200) {
                throw new VideoUnavailable(videoId);
            }
            return response.data;
        }
        catch (error) {
            if (axios.isAxiosError(error)) {
                const status = (_a = error.response) === null || _a === void 0 ? void 0 : _a.status;
                if (status === 404 || status === 410) {
                    throw new VideoUnavailable(videoId);
                }
                if (status === 403) {
                    // Possible IP block or geo-restriction
                    throw new IpBlocked(videoId);
                }
            }
            throw new VideoUnavailable(videoId);
        }
    }
    /**
     * Extract video metadata from HTML
     * @param html Video page HTML
     * @returns VideoMetadata object
     * @private
     */
    extractMetadata(html) {
        var _a, _b, _c, _d, _e, _f;
        const metadataMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?})\s*;/);
        if (!metadataMatch) {
            throw new Error('Could not extract video metadata');
        }
        try {
            const data = JSON.parse(metadataMatch[1]);
            const videoDetails = data.videoDetails;
            if (!videoDetails) {
                throw new Error(`No video details found`);
            }
            return {
                id: videoDetails.videoId,
                title: decode(videoDetails.title),
                description: decode(videoDetails.shortDescription),
                author: decode(videoDetails.author),
                channelId: videoDetails.channelId,
                lengthSeconds: parseInt(videoDetails.lengthSeconds, 10),
                viewCount: parseInt(videoDetails.viewCount, 10),
                isPrivate: videoDetails.isPrivate,
                isLiveContent: videoDetails.isLiveContent,
                publishDate: (_b = (_a = data.microformat) === null || _a === void 0 ? void 0 : _a.playerMicroformatRenderer) === null || _b === void 0 ? void 0 : _b.publishDate,
                category: (_d = (_c = data.microformat) === null || _c === void 0 ? void 0 : _c.playerMicroformatRenderer) === null || _d === void 0 ? void 0 : _d.category,
                keywords: videoDetails.keywords,
                thumbnails: ((_f = (_e = videoDetails.thumbnail) === null || _e === void 0 ? void 0 : _e.thumbnails) === null || _f === void 0 ? void 0 : _f.map((thumb) => ({
                    url: thumb.url,
                    width: thumb.width,
                    height: thumb.height,
                }))) || [],
            };
        }
        catch (error) {
            throw new Error(`Failed to parse video metadata: ${error.message}`);
        }
    }
    /**
     * Retrieves the list of available transcripts for a video
     * @param videoIdOrUrl The ID or URL of the video
     * @returns A transcript list with available transcripts
     */
    async listTranscripts(videoIdOrUrl) {
        const videoId = YouTubeTranscriptApi.getVideoId(videoIdOrUrl);
        const html = await this.fetchVideoHtml(videoId);
        const captionsJson = this.extractCaptionsJson(html, videoId);
        return TranscriptList.build(this.httpClient, videoId, captionsJson);
    }
    /**
     * Extract captions data from HTML
     * @param html Video page HTML
     * @param videoId Video ID for error reporting
     * @returns Captions data object
     * @private
     */
    extractCaptionsJson(html, videoId) {
        var _a;
        const splittedHTML = html.split('"captions":');
        if (splittedHTML.length <= 1) {
            if (html.includes('class="g-recaptcha"')) {
                throw new IpBlocked(videoId);
            }
            if (!html.includes('"playabilityStatus":')) {
                throw new VideoUnavailable(videoId);
            }
            throw new TranscriptsDisabled(videoId);
        }
        try {
            const captionsData = (_a = JSON.parse(splittedHTML[1].split(',"videoDetails')[0].replace('\n', ''))) === null || _a === void 0 ? void 0 : _a['playerCaptionsTracklistRenderer'];
            if (!captionsData) {
                throw new TranscriptsDisabled(videoId);
            }
            if (!('captionTracks' in captionsData)) {
                throw new NoTranscriptFound(videoId, []);
            }
            return captionsData;
        }
        catch (error) {
            if (error instanceof VideoUnavailable ||
                error instanceof TranscriptsDisabled ||
                error instanceof NoTranscriptFound ||
                error instanceof IpBlocked) {
                throw error;
            }
            throw new TranscriptsDisabled(videoId);
        }
    }
}
/**
 * Internal class for managing transcript lists
 */
class TranscriptList {
    constructor(videoId, manualTranscripts, generatedTranscripts, translationLanguages) {
        this.videoId = videoId;
        this.manualTranscripts = manualTranscripts;
        this.generatedTranscripts = generatedTranscripts;
        this.translationLanguages = translationLanguages;
    }
    static build(httpClient, videoId, captionsJson) {
        const translationLanguages = (captionsJson.translationLanguages || []).map((lang) => ({
            languageName: lang.languageName.simpleText,
            languageCode: lang.languageCode,
        }));
        const manualTranscripts = new Map();
        const generatedTranscripts = new Map();
        (captionsJson.captionTracks || []).forEach((track) => {
            const transcript = new TranscriptEntry(httpClient, videoId, track.baseUrl, track.name.simpleText, track.languageCode, track.kind === 'asr', track.isTranslatable ? translationLanguages : []);
            if (track.kind === 'asr') {
                generatedTranscripts.set(track.languageCode, transcript);
            }
            else {
                manualTranscripts.set(track.languageCode, transcript);
            }
        });
        return new TranscriptList(videoId, manualTranscripts, generatedTranscripts, translationLanguages);
    }
    async findTranscript(languageCodes) {
        // Try manual transcripts first
        try {
            return this.findTranscriptInMap(languageCodes, this.manualTranscripts);
        }
        catch (error) {
            if (error instanceof NoTranscriptFound) {
                // Try generated transcripts if no manual transcript found
                return this.findTranscriptInMap(languageCodes, this.generatedTranscripts);
            }
            throw error;
        }
    }
    findTranscriptInMap(languageCodes, transcriptMap) {
        for (const languageCode of languageCodes) {
            const transcript = transcriptMap.get(languageCode);
            if (transcript) {
                return transcript;
            }
        }
        throw new NoTranscriptFound(this.videoId, languageCodes);
    }
}
/**
 * Internal class for transcript entries
 */
class TranscriptEntry {
    constructor(httpClient, videoId, url, language, languageCode, isGenerated, translationLanguages) {
        this.httpClient = httpClient;
        this.videoId = videoId;
        this.url = url;
        this.language = language;
        this.languageCode = languageCode;
        this.isGenerated = isGenerated;
        this.translationLanguages = translationLanguages;
    }
    async fetch(preserveFormatting = false) {
        try {
            const response = await this.httpClient.get(this.url);
            const snippets = this.parseTranscript(response.data, preserveFormatting);
            return {
                snippets,
                videoId: this.videoId,
                language: this.language,
                languageCode: this.languageCode,
                isGenerated: this.isGenerated,
            };
        }
        catch (error) {
            throw new VideoUnavailable(this.videoId);
        }
    }
    async translate(languageCode) {
        if (!this.isTranslatable()) {
            throw new NotTranslatable(this.videoId);
        }
        if (!this.translationLanguages.some(lang => lang.languageCode === languageCode)) {
            throw new TranslationLanguageNotAvailable(this.videoId, languageCode);
        }
        const translatedLanguage = this.translationLanguages.find(lang => lang.languageCode === languageCode);
        return new TranscriptEntry(this.httpClient, this.videoId, `${this.url}&tlang=${languageCode}`, translatedLanguage.languageName, languageCode, true, []);
    }
    isTranslatable() {
        return this.translationLanguages.length > 0;
    }
    getHtmlRegex(preserveFormatting) {
        if (preserveFormatting) {
            const formatsRegex = TranscriptEntry.FORMATTING_TAGS.join('|');
            return new RegExp(`<\\/?(?!\\/?(?:${formatsRegex})\\b).*?\\b>`, 'gi');
        }
        return /<[^>]*>/gi;
    }
    decodeAndClean(text) {
        // First decode XML entities
        let decoded = text
            .replace(/&quot;/g, '"')
            .replace(/&apos;/g, "'")
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        // Then decode HTML entities
        decoded = decode(decoded);
        // Replace common YouTube-specific entities
        decoded = decoded
            .replace(/\\u0026/g, '&')
            .replace(/\\"/g, '"')
            .replace(/\\/g, '');
        return decoded;
    }
    parseTranscript(xmlString, preserveFormatting) {
        const snippets = [];
        let match;
        const htmlRegex = this.getHtmlRegex(preserveFormatting);
        // First decode the entire XML string to handle any escaped XML
        const decodedXml = this.decodeAndClean(xmlString);
        while ((match = TranscriptEntry.RE_XML_TRANSCRIPT.exec(decodedXml)) !== null) {
            const [, start, duration, text] = match;
            // Process the text content
            let processedText = this.decodeAndClean(text);
            if (!preserveFormatting) {
                // Remove HTML tags
                processedText = processedText.replace(htmlRegex, '');
                // Normalize whitespace
                processedText = processedText
                    .replace(/\s+/g, ' ')
                    .replace(/&#160;/g, ' ')
                    .replace(/&nbsp;/g, ' ')
                    .trim();
            }
            snippets.push({
                text: processedText,
                start: parseFloat(start),
                duration: parseFloat(duration),
            });
        }
        return snippets;
    }
}
TranscriptEntry.RE_XML_TRANSCRIPT = /<text start="([^"]*)" dur="([^"]*)">([^<]*)<\/text>/g;
TranscriptEntry.FORMATTING_TAGS = [
    'strong', // important
    'em', // emphasized
    'b', // bold
    'i', // italic
    'mark', // marked
    'small', // smaller
    'del', // deleted
    'ins', // inserted
    'sub', // subscript
    'sup', // superscript
];
// Default export
export default YouTubeTranscriptApi;
//# sourceMappingURL=api.js.map