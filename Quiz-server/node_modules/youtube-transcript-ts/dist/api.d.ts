import { AxiosInstance } from 'axios';
import { FormatterType } from './formatters';
import { Transcript, TranscriptResponse, TranslationLanguage } from './types';
interface CacheOptions {
    enabled: boolean;
    maxAge: number;
}
interface LoggerOptions {
    enabled: boolean;
    namespace: string;
    /**
     * Custom logger function
     * Return true to prevent default logging behavior
     */
    logger?: (type: string, message: string, data?: any) => boolean;
}
/**
 * Invidious configuration options for fallback when YouTube blocks requests
 */
export interface InvidiousOptions {
    /** Enable Invidious fallback (default: false) */
    enabled: boolean;
    /**
     * Invidious instance URL(s). Can be a single URL string or an array of URLs for fallback.
     * If an array is provided, instances will be tried in order until one works.
     */
    instanceUrls: string | string[];
    /** Timeout in milliseconds for Invidious requests (default: 10000) */
    timeout?: number;
}
/**
 * Proxy configuration options for HTTP/HTTPS requests
 */
export interface ProxyOptions {
    /** Enable proxy for requests (default: false) */
    enabled: boolean;
    /** The HTTP proxy URL (e.g., 'http://user:pass@proxy.example.com:8080') */
    http?: string;
    /** The HTTPS proxy URL (e.g., 'http://user:pass@proxy.example.com:8080') */
    https?: string;
}
/**
 * Configuration options for the YouTubeTranscriptApi
 */
export interface YouTubeTranscriptApiOptions {
    /** Cache configuration options */
    cache?: Partial<CacheOptions>;
    /** Logger configuration options */
    logger?: Partial<LoggerOptions>;
    /** Invidious fallback configuration options */
    invidious?: Partial<InvidiousOptions>;
    /** Proxy configuration options */
    proxy?: Partial<ProxyOptions>;
}
/**
 * Main YouTube Transcript API class for fetching and processing transcripts
 */
export declare class YouTubeTranscriptApi {
    private httpClient;
    private invidiousClient;
    private cache;
    private cacheOptions;
    private loggerOptions;
    private invidiousOptions;
    private proxyOptions;
    /**
     * Create a new YouTubeTranscriptApi instance
     * @param options Configuration options for the API
     */
    constructor(options?: YouTubeTranscriptApiOptions);
    /**
     * Configure logging behavior
     * @param options Logger configuration options
     */
    setLoggerOptions(options: Partial<LoggerOptions>): void;
    /**
     * Configure caching behavior
     * @param options Cache configuration options
     */
    setCacheOptions(options: Partial<CacheOptions>): void;
    /**
     * Configure proxy settings for all requests
     * @param options Proxy configuration options
     */
    setProxyOptions(options: Partial<ProxyOptions>): void;
    /**
     * Configure Invidious fallback behavior
     * @param options Invidious configuration options
     */
    setInvidiousOptions(options: Partial<InvidiousOptions>): void;
    /**
     * Initialize the Invidious API client
     * @private
     */
    private initInvidiousClient;
    /**
     * Validate that the configured Invidious instance is available and working
     * @private
     */
    private validateInvidiousInstance;
    /**
     * Tries to get an Invidious instance that works
     * @param operation The operation to perform with the client
     * @returns The result of the operation
     * @private
     */
    private tryWithInvidiousInstances;
    /**
     * Sets cookies for authentication (useful for age-restricted videos)
     * @param cookies Dictionary of cookie name-value pairs
     */
    setCookies(cookies: Record<string, string>): void;
    /**
     * Internal method to log messages
     * @param type Type of log (e.g., 'performance', 'error')
     * @param message Log message
     * @param data Optional data to log
     * @private
     */
    private log;
    /**
     * Clear the internal cache
     * @param type Optional cache type to clear (html, transcript, or both if undefined)
     */
    clearCache(type?: 'html' | 'transcript'): void;
    /**
     * Extracts video ID from various YouTube URL formats or returns the ID if already an ID
     * @param videoIdOrUrl Video ID or YouTube URL (various formats supported)
     * @returns Extracted video ID
     */
    static getVideoId(videoIdOrUrl: string): string;
    /**
     * Check if a cached entry is still valid
     * @param entry The cache entry to check
     * @returns True if the entry is valid, false if expired
     * @private
     */
    private isCacheValid;
    /**
     * Fetch transcript for a video
     * @param videoIdOrUrl Video ID or YouTube URL
     * @param languages Optional array of language codes to try in order
     * @param preserveFormatting Whether to preserve text formatting
     * @param formatter Optional formatter to format the output
     * @returns TranscriptResponse with transcript data and metadata
     */
    fetchTranscript(videoIdOrUrl: string, languages?: string[], preserveFormatting?: boolean, formatter?: FormatterType): Promise<TranscriptResponse>;
    /**
     * Fetches a transcript from Invidious API
     * @param videoId YouTube video ID
     * @param languages List of language codes to search for (in order of preference)
     * @param preserveFormatting Whether to keep select HTML text formatting
     * @param formatter Optional formatter to format the output (json, text, srt, webvtt)
     * @returns TranscriptResponse with data from Invidious
     * @private
     */
    private fetchTranscriptFromInvidious;
    /**
     * Parses WebVTT format returned by Invidious
     * @param vttContent The WebVTT content as string
     * @param preserveFormatting Whether to preserve HTML formatting
     * @returns Array of transcript snippets
     */
    private parseWebVTT;
    /**
     * Converts WebVTT timestamp to seconds
     * @param timestamp WebVTT timestamp (HH:MM:SS.mmm)
     * @returns Time in seconds
     */
    private timeToSeconds;
    /**
     * Fetch video HTML content
     * @param videoId Video ID
     * @returns HTML content as string
     * @private
     */
    private fetchVideoHtml;
    /**
     * Extract video metadata from HTML
     * @param html Video page HTML
     * @returns VideoMetadata object
     * @private
     */
    private extractMetadata;
    /**
     * Retrieves the list of available transcripts for a video
     * @param videoIdOrUrl The ID or URL of the video
     * @returns A transcript list with available transcripts
     */
    listTranscripts(videoIdOrUrl: string): Promise<TranscriptList>;
    /**
     * Extract captions data from HTML
     * @param html Video page HTML
     * @param videoId Video ID for error reporting
     * @returns Captions data object
     * @private
     */
    private extractCaptionsJson;
}
/**
 * Internal class for managing transcript lists
 */
declare class TranscriptList {
    private videoId;
    private manualTranscripts;
    private generatedTranscripts;
    private translationLanguages;
    constructor(videoId: string, manualTranscripts: Map<string, TranscriptEntry>, generatedTranscripts: Map<string, TranscriptEntry>, translationLanguages: TranslationLanguage[]);
    static build(httpClient: AxiosInstance, videoId: string, captionsJson: any): TranscriptList;
    findTranscript(languageCodes: string[]): Promise<TranscriptEntry>;
    private findTranscriptInMap;
}
/**
 * Internal class for transcript entries
 */
declare class TranscriptEntry {
    private httpClient;
    private videoId;
    private url;
    private language;
    private languageCode;
    private isGenerated;
    private translationLanguages;
    private static readonly RE_XML_TRANSCRIPT;
    private static readonly FORMATTING_TAGS;
    constructor(httpClient: AxiosInstance, videoId: string, url: string, language: string, languageCode: string, isGenerated: boolean, translationLanguages: TranslationLanguage[]);
    fetch(preserveFormatting?: boolean): Promise<Transcript>;
    translate(languageCode: string): Promise<TranscriptEntry>;
    private isTranslatable;
    private getHtmlRegex;
    private decodeAndClean;
    private parseTranscript;
}
export default YouTubeTranscriptApi;
//# sourceMappingURL=api.d.ts.map